/// Fixture generator for Π_CCS k=2 tests
/// This generates pre-computed test data and stores it in the fixtures directory
use neo_transcript::{Poseidon2Transcript, Transcript};
use neo_ccs::{r1cs_to_ccs, Mat, McsInstance, McsWitness, MeInstance, SModuleHomomorphism};
use neo_math::{F, K, D};
use neo_params::NeoParams;
use neo_ajtai::Commitment;
use p3_field::PrimeCharacteristicRing;
use std::fs;
use std::path::Path;
use std::io::Write;

struct DummyS;

impl SModuleHomomorphism<F, Commitment> for DummyS {
    fn commit(&self, z: &Mat<F>) -> Commitment {
        let d = z.rows();
        Commitment::zeros(d, 4)
    }
    
    fn project_x(&self, z: &Mat<F>, m_in: usize) -> Mat<F> {
        let rows = z.rows();
        let cols = m_in.min(z.cols());
        let mut result = Mat::zero(rows, cols, F::ZERO);
        for r in 0..rows {
            for c in 0..cols {
                result[(r, c)] = z[(r, c)];
            }
        }
        result
    }
}

fn create_test_ccs() -> neo_ccs::CcsStructure<F> {
    let rows: usize = 4;
    let cols: usize = 5;
    
    let mut a = vec![F::ZERO; rows * cols];
    let mut b = vec![F::ZERO; rows * cols];
    let c = vec![F::ZERO; rows * cols];
    
    a[0 * cols + 4] = F::ONE;
    a[0 * cols + 1] = -F::ONE;
    a[0 * cols + 2] = -F::ONE;
    b[0 * cols + 0] = F::ONE;
    
    for row in 1..rows {
        b[row * cols + 0] = F::ONE;
    }
    
    r1cs_to_ccs(
        Mat::from_row_major(rows, cols, a),
        Mat::from_row_major(rows, cols, b),
        Mat::from_row_major(rows, cols, c),
    )
}

#[allow(non_snake_case)]
fn create_mcs_from_witness(
    params: &NeoParams,
    z_full: Vec<F>,
    m_in: usize,
    l: &DummyS,
) -> (McsInstance<Commitment, F>, McsWitness<F>) {
    let d = D;
    let m = z_full.len();
    
    let z_digits = neo_ajtai::decomp_b(&z_full, params.b, d, neo_ajtai::DecompStyle::Balanced);
    let mut row_major = vec![F::ZERO; d * m];
    for col in 0..m {
        for row in 0..d {
            row_major[row * m + col] = z_digits[col * d + row];
        }
    }
    let Z = Mat::from_row_major(d, m, row_major);
    let c_commit = l.commit(&Z);
    
    let mcs_instance = McsInstance {
        c: c_commit.clone(),
        x: z_full[..m_in].to_vec(),
        m_in,
    };
    
    let mcs_witness = McsWitness {
        w: z_full[m_in..].to_vec(),
        Z,
    };
    
    (mcs_instance, mcs_witness)
}

#[allow(non_snake_case)]
fn create_me_from_mcs(
    params: &NeoParams,
    ccs: &neo_ccs::CcsStructure<F>,
    mcs_instance: McsInstance<Commitment, F>,
    mcs_witness: McsWitness<F>,
    l: &DummyS,
) -> (MeInstance<Commitment, F, K>, Mat<F>) {
    let mut tr = Poseidon2Transcript::new(b"test/fixture/k1");
    let prove_result = neo_fold::pi_ccs_prove_simple(
        &mut tr,
        params,
        ccs,
        &[mcs_instance],
        &[mcs_witness.clone()],
        l,
    );
    
    let (me_outputs, _proof) = prove_result.expect("k=1 fold failed");
    assert_eq!(me_outputs.len(), 1);
    (me_outputs[0].clone(), mcs_witness.Z)
}

#[test]
#[ignore]
fn generate_k2_fixtures() {
    let fixture_dir = Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("tests-core")
        .join("fixtures");
    
    fs::create_dir_all(&fixture_dir).expect("Failed to create fixtures directory");
    
    let params = NeoParams::goldilocks_for_circuit(3, 2, 2);
    let ccs = create_test_ccs();
    let l = DummyS;
    let m_in = 1;
    
    println!("\n===============================================");
    println!("Generating k=2 Π_CCS test fixtures");
    println!("===============================================\n");
    
    // Create a README
    let readme = r#"# K=2 Π_CCS Test Fixtures

This directory contains pre-computed test fixtures for k=2 folding tests.

## Fixture Sets

### k2_honest (Basic k=2 fold)
- Computation 1: 2 + 3 = 5
- Computation 2: 7 + 11 = 18
- Tests basic k=2 folding: 1 MCS + 1 ME → 2 ME outputs

### k2_ivc (IVC simulation)
- Step 0: 1 + 1 = 2 (folded to ME)
- Step 1: 5 + 7 = 12 (folded with Step 0's ME)
- Tests IVC-like usage where prior state is folded with new computation

## Usage

These fixtures are loaded dynamically by the test code in `06_integration_pi_ccs_k2_smoke.rs`.
The fixtures are re-created by the helper functions in that file since the cryptographic
types (Commitment, MeInstance) cannot be easily serialized/deserialized.

## Generation

Generated by: `cargo test --package neo-fold --test core fixture_gen::generate_k2_fixtures -- --ignored --nocapture`
"#;
    
    fs::write(fixture_dir.join("README.md"), readme)
        .expect("Failed to write README");
    
    // Write fixture configurations as text for reference
    let mut config_file = fs::File::create(fixture_dir.join("k2_honest.txt")).expect("Failed to create config file");
    writeln!(config_file, "K=2 Honest Fold Fixture").unwrap();
    writeln!(config_file, "=====================").unwrap();
    writeln!(config_file, "").unwrap();
    writeln!(config_file, "Parameters:").unwrap();
    writeln!(config_file, "  b: {}", params.b).unwrap();
    writeln!(config_file, "  d: {}", D).unwrap();
    writeln!(config_file, "  m_in: {}", m_in).unwrap();
    writeln!(config_file, "").unwrap();
    writeln!(config_file, "MCS Witness 1: 2 + 3 = 5").unwrap();
    writeln!(config_file, "  z = [1, 2, 3, 0, 5]").unwrap();
    writeln!(config_file, "").unwrap();
    writeln!(config_file, "MCS Witness 2: 7 + 11 = 18 (converted to ME)").unwrap();
    writeln!(config_file, "  z = [1, 7, 11, 0, 18]").unwrap();
    
    let mut config_file2 = fs::File::create(fixture_dir.join("k2_ivc.txt")).expect("Failed to create config file");
    writeln!(config_file2, "K=2 IVC Simulation Fixture").unwrap();
    writeln!(config_file2, "==========================").unwrap();
    writeln!(config_file2, "").unwrap();
    writeln!(config_file2, "Parameters:").unwrap();
    writeln!(config_file2, "  b: {}", params.b).unwrap();
    writeln!(config_file2, "  d: {}", D).unwrap();
    writeln!(config_file2, "  m_in: {}", m_in).unwrap();
    writeln!(config_file2, "").unwrap();
    writeln!(config_file2, "Step 0: 1 + 1 = 2 (converted to ME)").unwrap();
    writeln!(config_file2, "  z = [1, 1, 1, 0, 2]").unwrap();
    writeln!(config_file2, "").unwrap();
    writeln!(config_file2, "Step 1: 5 + 7 = 12 (folded with Step 0)").unwrap();
    writeln!(config_file2, "  z = [1, 5, 7, 0, 12]").unwrap();
    
    println!("✓ Created fixture metadata files");
    println!("  - k2_honest.txt");
    println!("  - k2_ivc.txt");
    println!("  - README.md");
    
    // Generate and verify the fixtures actually work
    println!("\n===============================================");
    println!("Verifying fixture generation...");
    println!("===============================================\n");
    
    // Fixture 1: Basic honest fold
    {
        println!("Testing k2_honest fixture...");
        let z1_full = vec![F::ONE, F::from_u64(2), F::from_u64(3), F::ZERO, F::from_u64(5)];
        let (mcs_inst1, _mcs_wit1) = create_mcs_from_witness(&params, z1_full, m_in, &l);
        
        let z2_full = vec![F::ONE, F::from_u64(7), F::from_u64(11), F::ZERO, F::from_u64(18)];
        let (mcs_inst2, mcs_wit2) = create_mcs_from_witness(&params, z2_full, m_in, &l);
        let (me_input, _me_witness_z) = create_me_from_mcs(&params, &ccs, mcs_inst2, mcs_wit2, &l);
        
        println!("  MCS instance 1 created: m_in={}, x={:?}", mcs_inst1.m_in, mcs_inst1.x);
        println!("  ME instance created: m_in={}, r.len()={}", me_input.m_in, me_input.r.len());
        println!("✓ k2_honest fixture validates correctly\n");
    }
    
    // Fixture 2: IVC simulation
    {
        println!("Testing k2_ivc fixture...");
        let z_step0 = vec![F::ONE, F::ONE, F::ONE, F::ZERO, F::from_u64(2)];
        let (mcs0, wit0) = create_mcs_from_witness(&params, z_step0, m_in, &l);
        let (me_step0, _z_step0_mat) = create_me_from_mcs(&params, &ccs, mcs0, wit0, &l);
        
        let z_step1 = vec![F::ONE, F::from_u64(5), F::from_u64(7), F::ZERO, F::from_u64(12)];
        let (mcs1, _wit1) = create_mcs_from_witness(&params, z_step1, m_in, &l);
        
        println!("  Step 0 ME created: m_in={}, r.len()={}", me_step0.m_in, me_step0.r.len());
        println!("  Step 1 MCS created: m_in={}, x={:?}", mcs1.m_in, mcs1.x);
        println!("✓ k2_ivc fixture validates correctly\n");
    }
    
    println!("===============================================");
    println!("✓ All fixtures generated and verified!");
    println!("===============================================");
    println!("\nFixture directory: {}", fixture_dir.display());
    println!("\nNote: The actual fixtures are generated dynamically in the tests");
    println!("because the cryptographic types cannot be easily serialized.");
    println!("The fixture files above document the test parameters for reference.");
}
